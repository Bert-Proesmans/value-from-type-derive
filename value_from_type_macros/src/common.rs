use heck::CamelCase;
use proc_macro;
use proc_macro2::{self, Span};
use syn::spanned::Spanned;
use syn::{self, Ident, Item, ItemMod, ItemStruct, Variant};

// Macro imports
use super::quote;

/// Select all ItemStructs from the provided ItemMod AST.
#[allow(dead_code)]
pub fn filter_structs_mut<'a>(data: &'a mut ItemMod) -> impl Iterator<Item = &'a mut ItemStruct> {
    data.content
        .iter_mut()
        .flat_map(|content| content.1.iter_mut())
        .flat_map(|item| {
            if let &mut Item::Struct(ref mut s) = item {
                Some(s)
            } else {
                None
            }
        })
}

/// Select all ItemStructs from the provided ItemMod AST.
pub fn filter_structs<'a>(data: &'a ItemMod) -> impl Iterator<Item = &'a ItemStruct> {
    data.content
        .iter()
        .flat_map(|content| content.1.iter())
        .flat_map(|item| {
            if let &Item::Struct(ref s) = item {
                Some(s)
            } else {
                None
            }
        })
}

/// Creates Invariant objects from each provided ItemStruct.
pub fn build_invariants<'a, I>(data: I) -> Result<Vec<Variant>, proc_macro::Diagnostic>
where
    I: IntoIterator<Item = &'a ItemStruct>,
{
    data.into_iter().map(internal_build_invariant).collect()
}

/// Creates an Invariant object which matches the provided structure.
pub fn internal_build_invariant(s: &ItemStruct) -> Result<Variant, proc_macro::Diagnostic> {
    let name = s.ident;
    let variant_span = name.span().resolved_at(Span::call_site());
    let variant_name = Ident::new(&name.as_ref().to_camel_case(), variant_span);

    // Build a doc attribute with some templated content.
    let doc_attr = format!("#[doc = \"Autogenerated. See [`{:}`].\"]", name.as_ref());
    let doc_attr: proc_macro::TokenStream = doc_attr.parse().unwrap();
    // Necessary for quote!{} to work!
    let doc_attr: proc_macro2::TokenStream = doc_attr.into();

    // TODO; Find out what attributes can/must be applied to each invariant.
    let variant_tokens = quote!{
        #doc_attr
        #variant_name
    };
    //
    syn::parse2(variant_tokens.into()).map_err(|e| {
        let msg = format!("Issue creating enum invariant `{:}`: {:}", name.as_ref(), e);
        variant_span.unstable().error(msg)
    })
}

// Push new contents into the AST representation of a module.
#[allow(dead_code)]
pub fn extend_module<I>(module: &mut ItemMod, items: I) -> Result<(), proc_macro::Diagnostic>
where
    I: IntoIterator,
    I::Item: Into<Item>,
{
    let mod_span = module.span();
    match module.content.as_mut() {
        Some(&mut (_, ref mut c)) => {
            c.extend(items.into_iter().map(Into::into));
            Ok(())
        }
        None => {
            let msg = "This module doesn't have any contents!";
            Err(mod_span.unstable().error(msg))
        }
    }
}

// Push new contents into the AST representation of a module.
pub fn push_into_module<I>(module: &mut ItemMod, item: I) -> Result<(), proc_macro::Diagnostic>
where
    I: Into<Item>,
{
    let mod_span = module.span();
    match module.content.as_mut() {
        Some(&mut (_, ref mut c)) => {
            c.push(item.into());
            Ok(())
        }
        None => {
            let msg = "This module doesn't have any contents!";
            Err(mod_span.unstable().error(msg))
        }
    }
}
